<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8" />
<meta name="generator" content="quarto-1.8.24" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />


<title>Selection Bias &amp; Missing Data Challenge - Part 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>

<!-- htmldependencies:E3FAD763 -->


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Selection Bias &amp; Missing Data Challenge - Part 1</h1>
<p class="subtitle lead">Blue Noise Stippling: Creating Art from Data</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="selection-bias-missing-data-challenge---part-1" class="level1">
<h1>üé® Selection Bias &amp; Missing Data Challenge - Part 1</h1>
<section id="the-problem-can-algorithms-create-art" class="level2">
<h2>The Problem: Can Algorithms Create Art?</h2>
<p><strong>Core Question:</strong> How can we convert a photograph into an aesthetically pleasing pattern of dots that preserves the visual information of the original image?</p>
<p><strong>The Challenge:</strong> Blue noise stippling is a technique that converts images into patterns of dots (stipples) using algorithms that balance visual accuracy with spatial distribution. This challenge asks you to implement a modified ‚Äúvoid and cluster‚Äù algorithm that combines importance sampling with blue noise distribution properties to create stippling patterns that are both visually accurate and spatially well-distributed.</p>
<p><strong>Our Approach:</strong> We‚Äôll use a modified void-and-cluster algorithm that: 1. Creates an importance map identifying visually important regions 2. Uses a toroidal (periodic) Gaussian kernel for repulsion to ensure blue noise properties 3. Iteratively selects points with minimum energy 4. Balances image content importance with blue noise spatial distribution</p>
</section>
<section id="introduction-to-blue-noise-stippling" class="level2">
<h2>Introduction to Blue Noise Stippling</h2>
<p>Blue noise stippling is a technique for converting images into a pattern of dots (stipples) that preserves the visual information of the original image while creating an aesthetically pleasing, evenly distributed pattern. This method follows the approach described by <a href="https://bartwronski.com/2022/08/31/progressive-image-stippling-and-greedy-blue-noise-importance-sampling/">Bart Wronski</a>.</p>
<p>The method uses a modified ‚Äúvoid and cluster‚Äù algorithm that combines importance sampling with blue noise distribution properties to create stippling patterns that are both visually accurate and spatially well-distributed. This version uses <strong>smooth extreme downweighting</strong> that selectively downweights very dark and very light tones while preserving mid-tones, creating a more balanced distribution of stipples across the image.</p>
</section>
<section id="loading-the-original-image" class="level2">
<h2>Loading the Original Image</h2>
<p>First, let‚Äôs load an image that we‚Äôll convert to a blue noise stippling pattern. You can use any image you‚Äôd like, but we‚Äôll demonstrate with the provided example.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-15-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-15-1" role="tab" aria-controls="tabset-15-1" aria-selected="true" href="">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-15-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-15-1-tab">
<div id="cell-load-image" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display">
<div id="load-image" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/load-image-output-1.png" width="358" height="469" /></p>
<figcaption>Original image before stippling</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image shape: (251, 201)
Image size: 251x201 pixels</code></pre>
</div>
</div>
<section id="importance-mapping" class="level2">
<h2>Importance Mapping</h2>
<p>Before applying the stippling algorithm, we create an <strong>importance map</strong> that identifies which regions of the image should receive more stipples. The importance map is computed by:</p>
<ul>
<li><strong>Brightness inversion</strong>: The image brightness is inverted so that dark areas receive higher importance and thus more dots, while light areas receive fewer dots</li>
<li><strong>Extreme tone downweighting</strong>: Smooth Gaussian functions downweight tones below 0.2 (very dark) and above 0.8 (very light), creating a gradual transition that preserves mid-tones</li>
<li><strong>Mid-tone boost</strong>: A smooth Gaussian function centered on mid-tones provides a gradual increase in importance for mid-tone regions, ensuring they receive appropriate stippling density</li>
<li><strong>Selective and effective</strong>: This approach ensures that stipples are distributed appropriately (more dots in dark areas and mid-tones, fewer in extreme dark/light areas) while maintaining good spatial distribution</li>
</ul>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-14-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-14-1" role="tab" aria-controls="tabset-14-1" aria-selected="true" href="">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-14-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-14-1-tab">
<section id="blue-noise-stippling-algorithm" class="level2">
<h2>Blue Noise Stippling Algorithm</h2>
<p>The stippling algorithm uses a modified void-and-cluster approach that:</p>
<ol type="1">
<li>Creates an importance map that identifies visually important regions</li>
<li>Initializes an energy field based on the importance map (higher importance ‚Üí lower energy)</li>
<li>Uses a toroidal (periodic) Gaussian kernel for repulsion to ensure blue noise properties</li>
<li>Iteratively selects points with minimum energy</li>
<li>Adds Gaussian ‚Äúsplats‚Äù around selected points to prevent clustering</li>
<li>Balances image content importance with blue noise spatial distribution</li>
</ol>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-13-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-13-1" role="tab" aria-controls="tabset-13-1" aria-selected="true" href="">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-13-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-13-1-tab">
<section id="preparing-the-working-image" class="level2">
<h2>Preparing the Working Image</h2>
<p>Before generating the stippling pattern, we prepare the image by resizing if necessary and computing the importance map.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-12-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-12-1" role="tab" aria-controls="tabset-12-1" aria-selected="true" href="">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-12-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-12-1-tab">
<div id="prep-image" class="cell" data-message="false" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>Final image shape: (251, 201) (should be 2D for grayscale)
Importance map computed</code></pre>
</div>
</div>
<section id="generating-the-stippled-image" class="level2">
<h2>Generating the Stippled Image</h2>
<p>Now let‚Äôs apply the stippling algorithm to create the blue noise stippling pattern.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-11-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-1" role="tab" aria-controls="tabset-11-1" aria-selected="true" href="">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-11-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-11-1-tab">
<div id="generate-stipple" class="cell" data-message="false" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>Generating blue noise stippling pattern...
Generated 4036 stipple points
Stipple pattern shape: (251, 201)</code></pre>
</div>
</div>
<section id="displaying-the-results" class="level2">
<h2>Displaying the Results</h2>
<p>Let‚Äôs visualize the original image, the importance map, and the stippled version side by side for comparison.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-10-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-10-1" role="tab" aria-controls="tabset-10-1" aria-selected="true" href="">Python</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-10-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-10-2" role="tab" aria-controls="tabset-10-2" aria-selected="false" href="">Darker Colors Focus</a></li></ul>
<div class="tab-content">
<div id="tabset-10-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-10-1-tab">
<div id="cell-display-results" class="cell" data-fig-height="4" data-fig-width="7" data-execution_count="6">
<div class="cell-output cell-output-display">
<div id="display-results" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/display-results-output-1.png" width="666" height="302" /></p>
<figcaption>Comparison of original image, importance map, and blue noise stippling</figcaption>
</figure>
</div>
</div>
</div>
<section id="experimental-variations" class="level2">
<h2>Experimental Variations</h2>
<p>Let‚Äôs experiment with different parameters and approaches to see how they affect the stippling results.</p>
</section>
</div>
<div id="tabset-10-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-10-2-tab">
<p>This experiment modifies the importance map to strongly prioritize darker areas, creating stipples that emphasize shadow regions.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-9-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-9-1" role="tab" aria-controls="tabset-9-1" aria-selected="true" href="">Python</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-9-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-9-2" role="tab" aria-controls="tabset-9-2" aria-selected="false" href=""></a></li></ul>
<div class="tab-content">
<div id="tabset-9-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-9-1-tab">
<div id="cell-darker-colors-experiment" class="cell" data-fig-height="4" data-fig-width="7" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>Image shape: (251, 201)
Generating stippling pattern (dark focus)...
Generated 4036 stipple points</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="darker-colors-experiment" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/darker-colors-experiment-output-2.png" width="669" height="302" /></p>
<figcaption>Stippling experiment focusing on darker colors</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Changes &amp; Why:</strong> - <strong>No Brightness Inversion</strong>: Removed 1.0-img inversion (dark areas naturally get higher importance) - <strong>Tighter Parameters</strong>: extreme_sigma=0.05 (sharper downweighting), mid_tone_sigma=0.15 (focused boost) - <strong>Enhanced Mid-tone Boost</strong>: Centered at 0.2 brightness with 80% weight for dark mid-tones - <strong>Reduced Extreme Downweighting</strong>: 0.15 (vs 0.2) to maintain some contrast - <strong>Why</strong>: Strongly emphasizes dark areas (jersey) while preserving mid-tone details, creating shadow-focused stippling</p>
</div>
<div id="tabset-9-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-9-2-tab">
<section id="edge-enhanced-player-focus" class="level3">
<h3>Edge-Enhanced Player Focus</h3>
<p>This experiment uses edge detection to emphasize the player‚Äôs silhouette and features, making him stand out from the background through contrast enhancement.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-8-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-1" role="tab" aria-controls="tabset-8-1" aria-selected="true" href="">Python</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-8-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-2" role="tab" aria-controls="tabset-8-2" aria-selected="false" href=""></a></li></ul>
<div class="tab-content">
<div id="tabset-8-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-8-1-tab">
<div id="cell-edge-enhanced-player-experiment" class="cell" data-fig-height="4" data-fig-width="7" data-execution_count="8">
<div class="cell-output cell-output-stdout">
<pre><code>Image shape: (251, 201)
Generating edge-enhanced stippling pattern...
Generated 5045 stipple points</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="edge-enhanced-player-experiment" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/edge-enhanced-player-experiment-output-2.png" width="662" height="302" /></p>
<figcaption>Edge-enhanced stippling to make the player pop out</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Changes &amp; Why:</strong> - <strong>Edge Detection</strong>: Added Sobel operator edge detection to find boundaries - <strong>Local Contrast</strong>: Measured variance in 5x5 windows for high-contrast areas - <strong>Combined Boost</strong>: Edge + contrast signals added to base importance (60% weight each) - <strong>Higher Density</strong>: 10% points (vs 8%) for more detail on player features - <strong>Balanced Sigma</strong>: 0.8 for good clustering without over-smoothing - <strong>Why</strong>: Emphasizes player silhouette through contrast enhancement, making him pop from background</p>
</div>
<div id="tabset-8-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-8-2-tab">
<section id="contrast-based-player-isolation" class="level3">
<h3>Contrast-Based Player Isolation</h3>
<p>This experiment creates an importance map based on local contrast patterns, boosting areas where bright regions (player‚Äôs skin) meet dark regions (jersey), creating a silhouette effect.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-7-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-1" role="tab" aria-controls="tabset-7-1" aria-selected="true" href="">Python</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-7-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-2" role="tab" aria-controls="tabset-7-2" aria-selected="false" href=""></a></li></ul>
<div class="tab-content">
<div id="tabset-7-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-7-1-tab">
<div id="cell-contrast-player-experiment" class="cell" data-fig-height="4" data-fig-width="7" data-execution_count="9">
<div class="cell-output cell-output-stdout">
<pre><code>Image shape: (251, 201)
Generating contrast-based player stippling pattern...
Generated 4036 stipple points</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="contrast-player-experiment" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/contrast-player-experiment-output-2.png" width="662" height="302" /></p>
<figcaption>Contrast-based stippling to isolate the player silhouette</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Changes &amp; Why:</strong> - <strong>Local Range Analysis</strong>: Used 7x7 sliding windows to measure brightness range (max-min) - <strong>Medium Brightness Focus</strong>: Gaussian boost centered on 0.5 brightness for skin-jersey boundaries - <strong>Dark Area Boost</strong>: Additional emphasis on pure dark areas (jersey) with tight sigma (0.15) - <strong>Background Suppression</strong>: Reduced importance for very bright areas (background) by 70% - <strong>High Content Bias</strong>: 0.95 (vs 0.9) for better shape preservation - <strong>Why</strong>: Creates figure-ground separation by isolating high-contrast player regions from uniform background</p>
</div>
<div id="tabset-7-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-7-2-tab">
<section id="high-density-stippling-12" class="level3">
<h3>High Density Stippling (12%)</h3>
<p>This experiment uses a higher percentage of stipple points (12% instead of 8%) to create denser stippling.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-6-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-1" role="tab" aria-controls="tabset-6-1" aria-selected="true" href="">Python</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-6-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-2" role="tab" aria-controls="tabset-6-2" aria-selected="false" href=""></a></li></ul>
<div class="tab-content">
<div id="tabset-6-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-6-1-tab">
<div id="cell-high-density-experiment" class="cell" data-fig-height="4" data-fig-width="7" data-execution_count="10">
<div class="cell-output cell-output-stdout">
<pre><code>Generating high-density stippling pattern...
Generated 6054 stipple points</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="high-density-experiment" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/high-density-experiment-output-2.png" width="662" height="302" /></p>
<figcaption>High density stippling experiment (12% points)</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Changes &amp; Why:</strong> - <strong>Higher Density</strong>: percentage=0.12 (vs 0.08) for 50% more stipple points - <strong>Same Parameters</strong>: All other settings identical to baseline (sigma=0.9, content_bias=0.9) - <strong>Why</strong>: Creates denser, more detailed stippling with finer granularity, revealing more image features</p>
</div>
<div id="tabset-6-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-6-2-tab">
<section id="low-density-stippling-5" class="level3">
<h3>Low Density Stippling (5%)</h3>
<p>This experiment uses a lower percentage of stipple points (5% instead of 8%) to create sparser stippling.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-5-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-1" role="tab" aria-controls="tabset-5-1" aria-selected="true" href="">Python</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-5-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-2" role="tab" aria-controls="tabset-5-2" aria-selected="false" href=""></a></li></ul>
<div class="tab-content">
<div id="tabset-5-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-5-1-tab">
<div id="cell-low-density-experiment" class="cell" data-fig-height="4" data-fig-width="7" data-execution_count="11">
<div class="cell-output cell-output-stdout">
<pre><code>Generating low-density stippling pattern...
Generated 2522 stipple points</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="low-density-experiment" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/low-density-experiment-output-2.png" width="662" height="302" /></p>
<figcaption>Low density stippling experiment (5% points)</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Changes &amp; Why:</strong> - <strong>Lower Density</strong>: percentage=0.05 (vs 0.08) for 37% fewer stipple points - <strong>Same Parameters</strong>: All other settings identical to baseline (sigma=0.9, content_bias=0.9) - <strong>Why</strong>: Creates minimal, artistic stippling that captures essential shapes with fewer points, emphasizing bold contrasts</p>
</div>
<div id="tabset-5-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-5-2-tab">
<section id="high-sigma-stippling-œÉ1.2" class="level3">
<h3>High Sigma Stippling (œÉ=1.2)</h3>
<p>This experiment uses a higher sigma value (1.2 instead of 0.9) for the blue noise generation, creating more clustered stippling patterns.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-4-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-1" role="tab" aria-controls="tabset-4-1" aria-selected="true" href="">Python</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-4-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-2" role="tab" aria-controls="tabset-4-2" aria-selected="false" href=""></a></li></ul>
<div class="tab-content">
<div id="tabset-4-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-4-1-tab">
<div id="cell-high-sigma-experiment" class="cell" data-fig-height="4" data-fig-width="7" data-execution_count="12">
<div class="cell-output cell-output-stdout">
<pre><code>Generating high-sigma stippling pattern...
Generated 4036 stipple points</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="high-sigma-experiment" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/high-sigma-experiment-output-2.png" width="664" height="302" /></p>
<figcaption>High sigma stippling experiment (œÉ=1.2)</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Changes &amp; Why:</strong> - <strong>Higher Sigma</strong>: sigma=1.2 (vs 0.9) for blue noise generation - <strong>Same Parameters</strong>: All other settings identical to baseline (percentage=0.08, content_bias=0.9) - <strong>Why</strong>: Creates more clustered stippling with larger spacing variations, producing a more organic, less uniform distribution</p>
</div>
<div id="tabset-4-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-4-2-tab">
<section id="low-sigma-stippling-œÉ0.5" class="level3">
<h3>Low Sigma Stippling (œÉ=0.5)</h3>
<p>This experiment uses a lower sigma value (0.5 instead of 0.9) for the blue noise generation, creating more dispersed stippling patterns.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-3-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-1" role="tab" aria-controls="tabset-3-1" aria-selected="true" href="">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-3-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-3-1-tab">
<div id="cell-low-sigma-experiment" class="cell" data-fig-height="4" data-fig-width="7" data-execution_count="13">
<div class="cell-output cell-output-stdout">
<pre><code>Generating low-sigma stippling pattern...
Generated 4036 stipple points</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="low-sigma-experiment" class="quarto-figure quarto-figure-center">
<figure>
<p><img src="index_files/figure-html/low-sigma-experiment-output-2.png" width="662" height="302" /></p>
<figcaption>Low sigma stippling experiment (œÉ=0.5)</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Changes &amp; Why:</strong> - <strong>Lower Sigma</strong>: sigma=0.5 (vs 0.9) for blue noise generation - <strong>Same Parameters</strong>: All other settings identical to baseline (percentage=0.08, content_bias=0.9) - <strong>Why</strong>: Creates more dispersed stippling with smaller spacing variations, producing a more uniform, grid-like distribution</p>
<section id="how-the-parameter-changes-affect-the-final-result" class="level2">
<h2>How the parameter changes affect the final result</h2>
<p>-The different parameters affect the result in different ways. Some emphasize the dark jersey areas, some emphasize the player silhouette, some emphasize the background, some emphasize the mid-tones. There are also different levels of clustering done depending on parameter settings. All these affect how much or little Drake pops out from the background and his jersey. The best results came from the original, the high density, and the player edge focus settings. These settings created the most balanced and visually pleasing results. ####</p>
</section>
<section id="progressive-stippling-animation" class="level2">
<h2>Progressive Stippling Animation</h2>
<p>This section creates a GIF showing how the stippled image looks as more points are added sequentially. We‚Äôll use the already-computed stippling points to generate frames at increments of 100 points.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-2-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-1" role="tab" aria-controls="tabset-2-1" aria-selected="true" href="">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-2-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-2-1-tab">
<div id="progressive-stippling" class="cell" data-message="false" data-execution_count="14">
<div class="cell-output cell-output-stdout">
<pre><code>Using existing stippling with 4036 points
Image shape: (251, 201)
Generated 42 frames
Point counts: [1, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700, 2800, 2900, 3000, 3100, 3200, 3300, 3400, 3500, 3600, 3700, 3800, 3900, 4000, 4036]</code></pre>
</div>
</div>
<p>Now let‚Äôs create the GIF animation:</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img src="progressive_stippling.gif" class="img-fluid" /></p>
<figcaption>Progressive stippling animation showing the sequential build-up of points. Each frame represents an increment of 100 points, demonstrating how the blue noise stippling pattern develops as more points are added.</figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id = "quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->

</body>

</html>
