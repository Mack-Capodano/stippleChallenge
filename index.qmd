---
title: "Selection Bias & Missing Data Challenge - Part 1"
subtitle: "Blue Noise Stippling: Creating Art from Data"
format:
  html: default
  pdf: default
execute:
  echo: true
  eval: true
---

# ðŸŽ¨ Selection Bias & Missing Data Challenge - Part 1

## The Problem: Can Algorithms Create Art?

**Core Question:** How can we convert a photograph into an aesthetically pleasing pattern of dots that preserves the visual information of the original image?

**The Challenge:** Blue noise stippling is a technique that converts images into patterns of dots (stipples) using algorithms that balance visual accuracy with spatial distribution. This challenge asks you to implement a modified "void and cluster" algorithm that combines importance sampling with blue noise distribution properties to create stippling patterns that are both visually accurate and spatially well-distributed.

**Our Approach:** We'll use a modified void-and-cluster algorithm that:
1. Creates an importance map identifying visually important regions
2. Uses a toroidal (periodic) Gaussian kernel for repulsion to ensure blue noise properties
3. Iteratively selects points with minimum energy
4. Balances image content importance with blue noise spatial distribution



## Introduction to Blue Noise Stippling

Blue noise stippling is a technique for converting images into a pattern of dots (stipples) that preserves the visual information of the original image while creating an aesthetically pleasing, evenly distributed pattern. This method follows the approach described by [Bart Wronski](https://bartwronski.com/2022/08/31/progressive-image-stippling-and-greedy-blue-noise-importance-sampling/).

The method uses a modified "void and cluster" algorithm that combines importance sampling with blue noise distribution properties to create stippling patterns that are both visually accurate and spatially well-distributed. This version uses **smooth extreme downweighting** that selectively downweights very dark and very light tones while preserving mid-tones, creating a more balanced distribution of stipples across the image.

## Loading the Original Image

First, let's load an image that we'll convert to a blue noise stippling pattern. You can use any image you'd like, but we'll demonstrate with the provided example.

::: {.panel-tabset}

### Python

```{python}
#| label: load-image
#| echo: false
#| fig-cap: "Original image before stippling"

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

# Load the image
img_path = 'maye.jpeg'
original_img = Image.open(img_path)

# Convert to grayscale if needed
if original_img.mode != 'L':
    original_img = original_img.convert('L')

# Convert to numpy array and normalize to [0, 1]
img_array = np.array(original_img, dtype=np.float32) / 255.0

# Display the original image
fig, ax = plt.subplots(figsize=(6.5, 5))
ax.imshow(img_array, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Original Image', fontsize=14, fontweight='bold', pad=10)
plt.tight_layout()
plt.show()

print(f"Image shape: {img_array.shape}")
print(f"Image size: {img_array.shape[0]}x{img_array.shape[1]} pixels")
```




## Importance Mapping

Before applying the stippling algorithm, we create an **importance map** that identifies which regions of the image should receive more stipples. The importance map is computed by:

- **Brightness inversion**: The image brightness is inverted so that dark areas receive higher importance and thus more dots, while light areas receive fewer dots
- **Extreme tone downweighting**: Smooth Gaussian functions downweight tones below 0.2 (very dark) and above 0.8 (very light), creating a gradual transition that preserves mid-tones
- **Mid-tone boost**: A smooth Gaussian function centered on mid-tones provides a gradual increase in importance for mid-tone regions, ensuring they receive appropriate stippling density
- **Selective and effective**: This approach ensures that stipples are distributed appropriately (more dots in dark areas and mid-tones, fewer in extreme dark/light areas) while maintaining good spatial distribution

::: {.panel-tabset}

### Python

```{python}
#| label: importance-map
#| echo: false
#| message: false
#| warning: false

def compute_importance(
    gray_img: np.ndarray,
    extreme_downweight: float = 0.5,
    extreme_threshold_low: float = 0.4,
    extreme_threshold_high: float = 0.8,
    extreme_sigma: float = 0.1,
    mid_tone_boost: float = 0.4,
    mid_tone_sigma: float = 0.2,
):
    """
    Importance map computation that downweights extreme tones (very dark and very light)
    using smooth functions, while boosting mid-tones.
    
    Parameters
    ----------
    gray_img : np.ndarray
        Grayscale image in [0, 1]
    extreme_downweight : float
        Strength of downweighting for extreme tones (0.0 = no downweighting, 1.0 = maximum downweighting)
    extreme_threshold_low : float
        Threshold below which tones are considered "very dark" and get downweighted
    extreme_threshold_high : float
        Threshold above which tones are considered "very light" and get downweighted
    extreme_sigma : float
        Width of the smooth transition for extreme downweighting (smaller = sharper transition)
    mid_tone_boost : float
        Strength of mid-tone emphasis (0.0 = no boost, 1.0 = strong boost)
    mid_tone_sigma : float
        Width of the mid-tone Gaussian bump (smaller = narrower, larger = wider)
    
    Returns
    -------
    importance : np.ndarray
        Importance map in [0, 1]; higher = more stipples (dark areas and mid-tones get higher importance)
    """
    I = np.clip(gray_img, 0.0, 1.0)
    
    # Invert brightness: dark areas should get more dots (higher importance)
    I_inverted = 1.0 - I
    
    # Create smooth downweighting mask for extreme tones
    # Downweight very dark regions (I < extreme_threshold_low)
    dark_mask = np.exp(-((I - 0.0) ** 2) / (2.0 * (extreme_sigma ** 2)))
    dark_mask = np.where(I < extreme_threshold_low, dark_mask, 0.0)
    if dark_mask.max() > 0:
        dark_mask = dark_mask / dark_mask.max()
    
    # Downweight very light regions (I > extreme_threshold_high)
    light_mask = np.exp(-((I - 1.0) ** 2) / (2.0 * (extreme_sigma ** 2)))
    light_mask = np.where(I > extreme_threshold_high, light_mask, 0.0)
    if light_mask.max() > 0:
        light_mask = light_mask / light_mask.max()
    
    # Combine both masks
    extreme_mask = np.maximum(dark_mask, light_mask)
    
    # Apply smooth downweighting
    importance = I_inverted * (1.0 - extreme_downweight * extreme_mask)
    
    # Add smooth gradual mid-tone boost (Gaussian centered on 0.65)
    mid_tone_center = 0.65
    mid_tone_gaussian = np.exp(-((I - mid_tone_center) ** 2) / (2.0 * (mid_tone_sigma ** 2)))
    if mid_tone_gaussian.max() > 0:
        mid_tone_gaussian = mid_tone_gaussian / mid_tone_gaussian.max()
    
    # Boost importance in mid-tone regions
    importance = importance * (1.0 + mid_tone_boost * mid_tone_gaussian)
    
    # Normalize to [0,1]
    m, M = importance.min(), importance.max()
    if M > m: 
        importance = (importance - m) / (M - m)
    return importance
```



## Blue Noise Stippling Algorithm

The stippling algorithm uses a modified void-and-cluster approach that:

1. Creates an importance map that identifies visually important regions
2. Initializes an energy field based on the importance map (higher importance â†’ lower energy)
3. Uses a toroidal (periodic) Gaussian kernel for repulsion to ensure blue noise properties
4. Iteratively selects points with minimum energy
5. Adds Gaussian "splats" around selected points to prevent clustering
6. Balances image content importance with blue noise spatial distribution

::: {.panel-tabset}

### Python

```{python}
#| label: stippling-functions
#| echo: false
#| message: false
#| warning: false

import numpy as np

def toroidal_gaussian_kernel(h: int, w: int, sigma: float):
    """
    Create a periodic (toroidal) 2D Gaussian kernel centered at (0,0).
    The toroidal property means the kernel wraps around at the edges,
    ensuring consistent repulsion behavior regardless of point location.
    """
    y = np.arange(h)
    x = np.arange(w)
    # Compute toroidal distances (minimum distance considering wrapping)
    dy = np.minimum(y, h - y)[:, None]
    dx = np.minimum(x, w - x)[None, :]
    # Compute Gaussian
    kern = np.exp(-(dx**2 + dy**2) / (2.0 * sigma**2))
    s = kern.sum()
    if s > 0:
        kern /= s  # Normalize
    return kern


def void_and_cluster(
    input_img: np.ndarray,
    percentage: float = 0.08,
    sigma: float = 0.9,
    content_bias: float = 0.9,
    importance_img: np.ndarray | None = None,
    noise_scale_factor: float = 0.1,
):
    """
    Generate blue noise stippling pattern from input image using a modified
    void-and-cluster algorithm with content-weighted importance.
    """
    I = np.clip(input_img, 0.0, 1.0)
    h, w = I.shape

    # Compute or use provided importance map
    if importance_img is None:
        importance = compute_importance(I)
    else:
        importance = np.clip(importance_img, 0.0, 1.0)

    # Create toroidal Gaussian kernel for repulsion
    kernel = toroidal_gaussian_kernel(h, w, sigma)

    # Initialize energy field: lower energy â†’ more likely to be picked
    energy_current = -importance * content_bias

    # Stipple buffer: start with white background; selected points become black dots
    final_stipple = np.ones_like(I)
    samples = []

    # Helper function to roll kernel to an arbitrary position
    def energy_splat(y, x):
        """Get energy contribution by rolling the kernel to position (y, x)."""
        return np.roll(np.roll(kernel, shift=y, axis=0), shift=x, axis=1)

    # Number of points to select
    num_points = int(I.size * percentage)

    # Choose first point near center with minimal energy
    cy, cx = h // 2, w // 2
    r = min(20, h // 10, w // 10)
    ys = slice(max(0, cy - r), min(h, cy + r))
    xs = slice(max(0, cx - r), min(w, cx + r))
    region = energy_current[ys, xs]
    flat = np.argmin(region)
    y0 = flat // (region.shape[1]) + (cy - r)
    x0 = flat % (region.shape[1]) + (cx - r)

    # Place first point
    energy_current = energy_current + energy_splat(y0, x0)
    energy_current[y0, x0] = np.inf  # Prevent reselection
    samples.append((y0, x0, I[y0, x0]))
    final_stipple[y0, x0] = 0.0  # Black dot

    # Iteratively place remaining points
    for i in range(1, num_points):
        # Add exploration noise that decreases over time
        exploration = 1.0 - (i / num_points) * 0.5  # Decrease from 1.0 to 0.5
        noise = np.random.normal(0.0, noise_scale_factor * content_bias * exploration, size=energy_current.shape)
        energy_with_noise = energy_current + noise

        # Find position with minimum energy (with noise for exploration)
        pos_flat = np.argmin(energy_with_noise)
        y = pos_flat // w
        x = pos_flat % w

        # Add Gaussian splat to prevent nearby points from being selected
        energy_current = energy_current + energy_splat(y, x)
        energy_current[y, x] = np.inf  # Prevent reselection

        # Record the sample
        samples.append((y, x, I[y, x]))
        final_stipple[y, x] = 0.0  # Black dot

    return final_stipple, np.array(samples)
```


## Preparing the Working Image

Before generating the stippling pattern, we prepare the image by resizing if necessary and computing the importance map.

::: {.panel-tabset}

### Python

```{python}
#| label: prep-image
#| echo: false
#| message: false
#| warning: false

# Resize image if it's too large for faster processing
max_size = 512
if img_array.shape[0] > max_size or img_array.shape[1] > max_size:
    scale = max_size / max(img_array.shape[0], img_array.shape[1])
    new_size = (int(img_array.shape[1] * scale), int(img_array.shape[0] * scale))
    img_resized_pil = original_img.resize(new_size, Image.Resampling.LANCZOS)
    if img_resized_pil.mode != 'L':
        img_resized_pil = img_resized_pil.convert('L')
    img_resized = np.array(img_resized_pil, dtype=np.float32) / 255.0
    print(f"Resized image from {img_array.shape} to {img_resized.shape} for processing")
else:
    img_resized = img_array.copy()

# Ensure img_resized is 2D grayscale
if len(img_resized.shape) > 2:
    img_resized = img_resized[:, :, 0]
elif len(img_resized.shape) == 2:
    pass
else:
    raise ValueError(f"Unexpected image shape: {img_resized.shape}")

print(f"Final image shape: {img_resized.shape} (should be 2D for grayscale)")

# Compute importance map using default parameters
importance_map = compute_importance(
    img_resized,
    extreme_downweight=0.5,
    extreme_threshold_low=0.2,
    extreme_threshold_high=0.8,
    extreme_sigma=0.1
)
print("Importance map computed")
```


## Generating the Stippled Image

Now let's apply the stippling algorithm to create the blue noise stippling pattern.

::: {.panel-tabset}

### Python

```{python}
#| label: generate-stipple
#| echo: false
#| message: false
#| warning: false

# Generate stippling pattern
print("Generating blue noise stippling pattern...")
stipple_pattern, samples = void_and_cluster(
    img_resized,
    percentage=0.08,
    sigma=0.9,
    content_bias=0.9,
    importance_img=importance_map,
    noise_scale_factor=0.1
)

print(f"Generated {len(samples)} stipple points")
print(f"Stipple pattern shape: {stipple_pattern.shape}")
```


## Displaying the Results

Let's visualize the original image, the importance map, and the stippled version side by side for comparison.

::: {.panel-tabset}

### Python

```{python}
#| label: display-results
#| echo: false
#| fig-cap: "Comparison of original image, importance map, and blue noise stippling"
#| fig-width: 7
#| fig-height: 4

fig, axes = plt.subplots(1, 3, figsize=(7, 4))

# Display original image
axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)

# Display importance map
axes[1].imshow(importance_map, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Importance Map', fontsize=14, fontweight='bold', pad=10)

# Display stippled image
axes[2].imshow(stipple_pattern, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('Blue Noise Stippling', fontsize=14, fontweight='bold', pad=10)

plt.tight_layout()
plt.show()
```



## Experimental Variations

Let's experiment with different parameters and approaches to see how they affect the stippling results.

### Darker Colors Focus

This experiment modifies the importance map to strongly prioritize darker areas, creating stipples that emphasize shadow regions.

::: {.panel-tabset}

#### Python

```{python}
#| label: darker-colors-experiment
#| echo: false
#| fig-cap: "Stippling experiment focusing on darker colors"
#| fig-width: 7
#| fig-height: 4

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

# Load and prepare image (reuse existing variables)
print(f"Image shape: {img_resized.shape}")

# Create importance map that prioritizes DARK areas (enhanced version of original)
def create_dark_focus_importance_map(img, extreme_sigma=0.05, mid_tone_sigma=0.15):
    """
    Create importance map that strongly emphasizes dark areas
    """
    # Use original brightness (dark areas naturally get higher importance)
    brightness = img

    # Extreme tone downweighting (reduce very dark and very light areas)
    extreme_weight = np.exp(-((brightness - 0.0) / extreme_sigma)**2) + \
                     np.exp(-((brightness - 1.0) / extreme_sigma)**2)

    # Mid-tone boost (centered on darker mid-tones)
    mid_tone_boost = np.exp(-((brightness - 0.2) / mid_tone_sigma)**2)

    # Combine: strongly boost dark mid-tones, moderately downweight extremes
    importance = 0.2 + 0.8 * mid_tone_boost - 0.15 * extreme_weight
    importance = np.clip(importance, 0, 1)

    return importance

# Generate importance map for dark focus
dark_focus_map = create_dark_focus_importance_map(img_resized, extreme_sigma=0.05, mid_tone_sigma=0.15)

# Generate stippling pattern
print("Generating stippling pattern (dark focus)...")
dark_stipple_pattern, dark_samples = void_and_cluster(
    img_resized,
    percentage=0.08,
    sigma=0.9,
    content_bias=0.9,
    importance_img=dark_focus_map,
    noise_scale_factor=0.1
)

print(f"Generated {len(dark_samples)} stipple points")

# Display results
fig, axes = plt.subplots(1, 3, figsize=(7, 4))

# Display original image
axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)

# Display dark-focus importance map
axes[1].imshow(dark_focus_map, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Dark-Focus Map', fontsize=14, fontweight='bold', pad=10)

# Display stippled image
axes[2].imshow(dark_stipple_pattern, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('Dark-Focus Stippling', fontsize=14, fontweight='bold', pad=10)

plt.tight_layout()
plt.show()
```

**Changes & Why:**
- **No Brightness Inversion**: Removed 1.0-img inversion (dark areas naturally get higher importance)
- **Tighter Parameters**: extreme_sigma=0.05 (sharper downweighting), mid_tone_sigma=0.15 (focused boost)
- **Enhanced Mid-tone Boost**: Centered at 0.2 brightness with 80% weight for dark mid-tones
- **Reduced Extreme Downweighting**: 0.15 (vs 0.2) to maintain some contrast
- **Why**: Strongly emphasizes dark areas (jersey) while preserving mid-tone details, creating shadow-focused stippling

####

### Edge-Enhanced Player Focus

This experiment uses edge detection to emphasize the player's silhouette and features, making him stand out from the background through contrast enhancement.

::: {.panel-tabset}

#### Python

```{python}
#| label: edge-enhanced-player-experiment
#| echo: false
#| fig-cap: "Edge-enhanced stippling to make the player pop out"
#| fig-width: 7
#| fig-height: 4

import numpy as np
from scipy import ndimage
from PIL import Image
import matplotlib.pyplot as plt

# Load and prepare image (reuse existing variables)
print(f"Image shape: {img_resized.shape}")

# Create edge-enhanced importance map for player focus
def create_player_focus_importance_map(img, edge_sigma=1.0, contrast_boost=0.6):
    """
    Create importance map that emphasizes edges and high-contrast areas
    to make the player (white skin + dark jersey) pop out from background
    """
    # Base importance from inverted brightness (dark areas get more stipples)
    base_importance = 1.0 - img

    # Edge detection using Sobel operator
    sobel_x = ndimage.sobel(img, axis=0)
    sobel_y = ndimage.sobel(img, axis=1)
    edges = np.sqrt(sobel_x**2 + sobel_y**2)

    # Smooth edges slightly
    edges_smooth = ndimage.gaussian_filter(edges, sigma=edge_sigma)

    # Normalize edges to [0, 1]
    if edges_smooth.max() > 0:
        edges_smooth = edges_smooth / edges_smooth.max()

    # Local contrast measurement (standard deviation in small windows)
    local_std = ndimage.generic_filter(img, np.std, size=5)

    # Normalize local contrast
    if local_std.max() > 0:
        local_std = local_std / local_std.max()

    # Combine: base importance + edge boost + contrast boost
    importance = base_importance + contrast_boost * edges_smooth + contrast_boost * local_std

    # Normalize to [0, 1]
    if importance.max() > 0:
        importance = importance / importance.max()

    return importance

# Generate edge-enhanced importance map
player_focus_map = create_player_focus_importance_map(img_resized, edge_sigma=1.0, contrast_boost=0.6)

# Generate stippling pattern
print("Generating edge-enhanced stippling pattern...")
player_stipple_pattern, player_samples = void_and_cluster(
    img_resized,
    percentage=0.10,  # Slightly higher density for detail
    sigma=0.8,        # Balanced clustering
    content_bias=0.9,
    importance_img=player_focus_map,
    noise_scale_factor=0.1
)

print(f"Generated {len(player_samples)} stipple points")

# Display results
fig, axes = plt.subplots(1, 3, figsize=(7, 4))

# Display original image
axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)

# Display player-focus importance map
axes[1].imshow(player_focus_map, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Player-Focus Map', fontsize=14, fontweight='bold', pad=10)

# Display stippled image
axes[2].imshow(player_stipple_pattern, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('Player Edges', fontsize=12, fontweight='bold', pad=8)

plt.tight_layout()
plt.show()
```

**Changes & Why:**
- **Edge Detection**: Added Sobel operator edge detection to find boundaries
- **Local Contrast**: Measured variance in 5x5 windows for high-contrast areas
- **Combined Boost**: Edge + contrast signals added to base importance (60% weight each)
- **Higher Density**: 10% points (vs 8%) for more detail on player features
- **Balanced Sigma**: 0.8 for good clustering without over-smoothing
- **Why**: Emphasizes player silhouette through contrast enhancement, making him pop from background

####

### Contrast-Based Player Isolation

This experiment creates an importance map based on local contrast patterns, boosting areas where bright regions (player's skin) meet dark regions (jersey), creating a silhouette effect.

::: {.panel-tabset}

#### Python

```{python}
#| label: contrast-player-experiment
#| echo: false
#| fig-cap: "Contrast-based stippling to isolate the player silhouette"
#| fig-width: 7
#| fig-height: 4

import numpy as np
from scipy import ndimage
from PIL import Image
import matplotlib.pyplot as plt

# Load and prepare image (reuse existing variables)
print(f"Image shape: {img_resized.shape}")

# Create contrast-based importance map for player isolation
def create_contrast_player_importance_map(img, window_size=7, contrast_threshold=0.3):
    """
    Create importance map that emphasizes high-contrast regions,
    particularly where bright skin meets dark jersey
    """
    # Base importance from brightness (darker areas get more stipples)
    base_importance = img  # No inversion - we want to emphasize dark areas

    # Local contrast using range (max - min) in sliding windows
    local_max = ndimage.maximum_filter(img, size=window_size)
    local_min = ndimage.minimum_filter(img, size=window_size)
    local_range = local_max - local_min

    # Normalize local range
    if local_range.max() > 0:
        local_contrast = local_range / local_range.max()
    else:
        local_contrast = local_range

    # Find areas with medium brightness that have high local contrast
    # (likely the edges between skin and jersey)
    medium_brightness = np.exp(-((img - 0.5) / 0.2)**2)  # Gaussian centered on mid-tones

    # Boost areas with both medium brightness AND high local contrast
    contrast_boost = local_contrast * medium_brightness

    # Also boost pure dark areas (jersey)
    dark_boost = np.exp(-((img - 0.0) / 0.15)**2)

    # Combine importance maps
    importance = 0.4 * base_importance + 0.4 * contrast_boost + 0.2 * dark_boost

    # Ensure minimum importance for very bright areas (background)
    importance = np.where(img > 0.8, importance * 0.3, importance)

    # Clip to [0, 1]
    importance = np.clip(importance, 0, 1)

    return importance

# Generate contrast-based importance map
contrast_player_map = create_contrast_player_importance_map(img_resized, window_size=7, contrast_threshold=0.3)

# Generate stippling pattern
print("Generating contrast-based player stippling pattern...")
contrast_player_pattern, contrast_player_samples = void_and_cluster(
    img_resized,
    percentage=0.08,
    sigma=0.9,
    content_bias=0.95,  # Higher content bias for shape preservation
    importance_img=contrast_player_map,
    noise_scale_factor=0.1
)

print(f"Generated {len(contrast_player_samples)} stipple points")

# Display results
fig, axes = plt.subplots(1, 3, figsize=(7, 4))

# Display original image
axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)

# Display contrast-player importance map
axes[1].imshow(contrast_player_map, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Contrast-Player Map', fontsize=14, fontweight='bold', pad=10)

# Display stippled image
axes[2].imshow(contrast_player_pattern, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('Player Silhouette', fontsize=12, fontweight='bold', pad=8)

plt.tight_layout()
plt.show()
```

**Changes & Why:**
- **Local Range Analysis**: Used 7x7 sliding windows to measure brightness range (max-min)
- **Medium Brightness Focus**: Gaussian boost centered on 0.5 brightness for skin-jersey boundaries
- **Dark Area Boost**: Additional emphasis on pure dark areas (jersey) with tight sigma (0.15)
- **Background Suppression**: Reduced importance for very bright areas (background) by 70%
- **High Content Bias**: 0.95 (vs 0.9) for better shape preservation
- **Why**: Creates figure-ground separation by isolating high-contrast player regions from uniform background

####

### High Density Stippling (12%)

This experiment uses a higher percentage of stipple points (12% instead of 8%) to create denser stippling.

::: {.panel-tabset}

#### Python

```{python}
#| label: high-density-experiment
#| echo: false
#| fig-cap: "High density stippling experiment (12% points)"
#| fig-width: 7
#| fig-height: 4

# Generate stippling pattern with higher density
print("Generating high-density stippling pattern...")
high_density_pattern, high_density_samples = void_and_cluster(
    img_resized,
    percentage=0.12,  # Increased from 0.08 to 0.12
    sigma=0.9,
    content_bias=0.9,
    importance_img=importance_map,
    noise_scale_factor=0.1
)

print(f"Generated {len(high_density_samples)} stipple points")

# Display results
fig, axes = plt.subplots(1, 3, figsize=(7, 4))

# Display original image
axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)

# Display importance map
axes[1].imshow(importance_map, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Importance Map', fontsize=14, fontweight='bold', pad=10)

# Display high-density stippled image
axes[2].imshow(high_density_pattern, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('High Density (12%)', fontsize=14, fontweight='bold', pad=10)

plt.tight_layout()
plt.show()
```

**Changes & Why:**
- **Higher Density**: percentage=0.12 (vs 0.08) for 50% more stipple points
- **Same Parameters**: All other settings identical to baseline (sigma=0.9, content_bias=0.9)
- **Why**: Creates denser, more detailed stippling with finer granularity, revealing more image features

####

### Low Density Stippling (5%)

This experiment uses a lower percentage of stipple points (5% instead of 8%) to create sparser stippling.

::: {.panel-tabset}

#### Python

```{python}
#| label: low-density-experiment
#| echo: false
#| fig-cap: "Low density stippling experiment (5% points)"
#| fig-width: 7
#| fig-height: 4

# Generate stippling pattern with lower density
print("Generating low-density stippling pattern...")
low_density_pattern, low_density_samples = void_and_cluster(
    img_resized,
    percentage=0.05,  # Decreased from 0.08 to 0.05
    sigma=0.9,
    content_bias=0.9,
    importance_img=importance_map,
    noise_scale_factor=0.1
)

print(f"Generated {len(low_density_samples)} stipple points")

# Display results
fig, axes = plt.subplots(1, 3, figsize=(7, 4))

# Display original image
axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)

# Display importance map
axes[1].imshow(importance_map, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Importance Map', fontsize=14, fontweight='bold', pad=10)

# Display low-density stippled image
axes[2].imshow(low_density_pattern, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('Low Density (5%)', fontsize=14, fontweight='bold', pad=10)

plt.tight_layout()
plt.show()
```

**Changes & Why:**
- **Lower Density**: percentage=0.05 (vs 0.08) for 37% fewer stipple points
- **Same Parameters**: All other settings identical to baseline (sigma=0.9, content_bias=0.9)
- **Why**: Creates minimal, artistic stippling that captures essential shapes with fewer points, emphasizing bold contrasts

####

### High Sigma Stippling (Ïƒ=1.2)

This experiment uses a higher sigma value (1.2 instead of 0.9) for the blue noise generation, creating more clustered stippling patterns.

::: {.panel-tabset}

#### Python

```{python}
#| label: high-sigma-experiment
#| echo: false
#| fig-cap: "High sigma stippling experiment (Ïƒ=1.2)"
#| fig-width: 7
#| fig-height: 4

# Generate stippling pattern with higher sigma
print("Generating high-sigma stippling pattern...")
high_sigma_pattern, high_sigma_samples = void_and_cluster(
    img_resized,
    percentage=0.08,
    sigma=1.2,  # Increased from 0.9 to 1.2
    content_bias=0.9,
    importance_img=importance_map,
    noise_scale_factor=0.1
)

print(f"Generated {len(high_sigma_samples)} stipple points")

# Display results
fig, axes = plt.subplots(1, 3, figsize=(7, 4))

# Display original image
axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)

# Display importance map
axes[1].imshow(importance_map, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Importance Map', fontsize=14, fontweight='bold', pad=10)

# Display high-sigma stippled image
axes[2].imshow(high_sigma_pattern, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('High Sigma (Ïƒ=1.2)', fontsize=14, fontweight='bold', pad=10)

plt.tight_layout()
plt.show()
```

**Changes & Why:**
- **Higher Sigma**: sigma=1.2 (vs 0.9) for blue noise generation
- **Same Parameters**: All other settings identical to baseline (percentage=0.08, content_bias=0.9)
- **Why**: Creates more clustered stippling with larger spacing variations, producing a more organic, less uniform distribution

####

### Low Sigma Stippling (Ïƒ=0.5)

This experiment uses a lower sigma value (0.5 instead of 0.9) for the blue noise generation, creating more dispersed stippling patterns.

::: {.panel-tabset}

#### Python

```{python}
#| label: low-sigma-experiment
#| echo: false
#| fig-cap: "Low sigma stippling experiment (Ïƒ=0.5)"
#| fig-width: 7
#| fig-height: 4

# Generate stippling pattern with lower sigma
print("Generating low-sigma stippling pattern...")
low_sigma_pattern, low_sigma_samples = void_and_cluster(
    img_resized,
    percentage=0.08,
    sigma=0.5,  # Decreased from 0.9 to 0.5
    content_bias=0.9,
    importance_img=importance_map,
    noise_scale_factor=0.1
)

print(f"Generated {len(low_sigma_samples)} stipple points")

# Display results
fig, axes = plt.subplots(1, 3, figsize=(7, 4))

# Display original image
axes[0].imshow(img_resized, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Original Image', fontsize=14, fontweight='bold', pad=10)

# Display importance map
axes[1].imshow(importance_map, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Importance Map', fontsize=14, fontweight='bold', pad=10)

# Display low-sigma stippled image
axes[2].imshow(low_sigma_pattern, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('Low Sigma (Ïƒ=0.5)', fontsize=14, fontweight='bold', pad=10)

plt.tight_layout()
plt.show()
```

**Changes & Why:**
- **Lower Sigma**: sigma=0.5 (vs 0.9) for blue noise generation
- **Same Parameters**: All other settings identical to baseline (percentage=0.08, content_bias=0.9)
- **Why**: Creates more dispersed stippling with smaller spacing variations, producing a more uniform, grid-like distribution

## How the parameter changes affect the final result
-The different parameters affect the result in different ways. Some emphasize the dark jersey areas, some emphasize the player silhouette, some emphasize the background, some emphasize the mid-tones. There are also different levels of clustering done depending on parameter settings. All these affect how much or little Drake pops out from the background and his jersey. The best results came from the original, the high density, and the player edge focus settings. These settings created the most balanced and visually pleasing results. 
####



## Progressive Stippling Animation

This section creates a GIF showing how the stippled image looks as more points are added sequentially. We'll use the already-computed stippling points to generate frames at increments of 100 points.

::: {.panel-tabset}

### Python

```{python}
#| label: progressive-stippling
#| echo: false
#| message: false
#| warning: false

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
from matplotlib.animation import PillowWriter

# Use the existing samples array from the already-computed stippling
print(f"Using existing stippling with {len(samples)} points")
print(f"Image shape: {img_resized.shape}")

# Create progressive frames by adding points sequentially
frame_increment = 100
frames = []
point_counts = []

# Start with white background
h, w = img_resized.shape
progressive_stipple = np.ones_like(img_resized)

# Add first point and save initial frame
if len(samples) > 0:
    y0, x0, intensity0 = int(samples[0, 0]), int(samples[0, 1]), samples[0, 2]
    progressive_stipple[y0, x0] = 0.0
    frames.append(progressive_stipple.copy())
    point_counts.append(1)

# Add remaining points sequentially and save frames at increments
for i in range(1, len(samples)):
    y, x = int(samples[i, 0]), int(samples[i, 1])
    progressive_stipple[y, x] = 0.0  # Add black dot
    
    # Save frame at increments (100, 200, 300, ...) and at the end
    if (i + 1) % frame_increment == 0 or i == len(samples) - 1:
        frames.append(progressive_stipple.copy())
        point_counts.append(i + 1)

print(f"Generated {len(frames)} frames")
print(f"Point counts: {point_counts}")
```



Now let's create the GIF animation:

::: {.panel-tabset}

### Python

```{python}
#| label: create-gif
#| include: false
#| fig-cap: "Progressive stippling animation showing build-up of points"
#| message: false
#| warning: false

# Create figure for animation
fig, ax = plt.subplots(figsize=(7, 5))
ax.axis('off')

# Create the animation
print("Creating GIF animation...")
writer = PillowWriter(fps=2)  # 2 frames per second

gif_path = 'progressive_stippling.gif'
with writer.saving(fig, gif_path, dpi=100):
    for i in range(len(frames)):
        ax.clear()
        ax.axis('off')
        ax.imshow(frames[i], cmap='gray', vmin=0, vmax=1)
        ax.set_title(f'Progressive Stippling: {point_counts[i]} points', 
                     fontsize=14, fontweight='bold', pad=10)
        writer.grab_frame()

print(f"GIF saved to: {gif_path}")
print(f"Total frames: {len(frames)}")
print(f"Point counts: {point_counts}")
```



![Progressive stippling animation showing the sequential build-up of points. Each frame represents an increment of 100 points, demonstrating how the blue noise stippling pattern develops as more points are added.](progressive_stippling.gif)

